# 生信100天打卡系列
---
@[TOC](文章目录)


---
# [1/100]多组学分析基础知识

## 一、 生物学基础

### 1. 突变

* 突变水平：
  * **DNA水平**的突变：碱基的替换、缺失、插入等
  * **染色体水平**的突变：
    * 染色体结构变异：插入、缺失、重复、倒位、易位等
    * 染色体数量变异（21三体综合征等）

---

### 2. 重组

* 突变多样性的重组，造成了**遗传多样性的迅速的升高**

---

### 3. 单倍型

![](https://img-blog.csdnimg.cn/c048f39a9f6b409ea0ea7eb2fa3bfc64.jpeg#pic_center)
* **由好多个突变组成的一个染色体片段叫做一个单倍型， 进行共遗传。**
* 在这个系谱里面， **一个没有重组的最小的单位就算做一个单倍型**，也就是一个颜色代表着一个单倍型。重组越多，一个单倍型就会越小。
* 有多少祖先能够贡献给我们今天的遗传多样性呢？**取决于我们重组的数量**，如果重组的越多， 那么就会有越多的祖先有机会贡献给我们遗传多样性。重组的多少可以用每一个世代里面减数分裂发生的重组交换的次数来衡量
![蓝色为每代发生1个重组， 红色为2个重组](https://img-blog.csdnimg.cn/2da4ef816b6048f7b407576cf9e480ec.jpeg#pic_center)

---

### 4. 突变与单倍型的关系

* **突变一定是发生在单倍型上面的某一个位置**（不管是DNA水平还是染色体水平的突变），发生以后也还是**以单倍型为单位进行遗传**的。
* 突变一定是在**某一个个体内部发生**的，所以**频率会非常低**；只有当这个个体的单倍型贡献到子代群体时，它的频率才会升高， 才会在更多的子代个体中被捕捉到。
* 所以我们在做**关联分析**时，其实是在做**非常老的Mutation**。就是说它发生的**时间非常久远**，有足够的时间让它在这个群体中的频率变得非常高。
* 一般比较**新的Mutation**（10个generation以下，1-3个Mutation），我们在关联分析中是不关注的，但是这些比较新的Mutation， 由于只发生在某一个个体，所以对于我们重新**构建系谱**是非常有帮助的。
* 特殊情况：
  * **Y染色体**严格意义上是没有重组的，所以几乎一个大的宗室的男性的Y染色体几乎都是一样的，发生的Mutation非常少
  * **哺乳动物中的线粒体**几乎是通过母系遗传的，因此可以通过track线粒体的变异进行**母系的溯源**
  * 在**植物中的线粒体和叶绿体**会有一定比例的重组， 但也非常非常少，所以在**追溯祖先**时，一般都会用以上这些情况的染色体

---

### 5. 总结

* 遗传的最小单位是一个单倍型，并不是点突变或者是很小很小的片段，但随着重组这种大片段会变短，在变短的过程中，又会有新的突变在发生。
* 在==关联分析和做进化树==时，关注的基本都是**比较老的突变**；但在==溯源==时，一般会用比较**新的突变**，或者用父源染色体或线粒体叶绿体。
---
# [1/100]BWT算法（BWA， Bowtie， Bowtie2）

## 算法步骤

### 一、为参考基因组建立索引(index)

* 现有reference sequence :  ACAACAG , query sequence : CAA

1. 加 $

```python
A C A A C A G $
```

2. 构建矩阵M

```python
A C A A C A G $
$ A C A A C A G 
G $ A C A A C A
A G $ A C A A C 
C A G $ A C A A 
A C A G $ A C A 
A A C A G $ A C
C A A C A G $ A 
```

3. 按字典序，从第一列开始对矩阵M进行排序

```python
           # F, L 为column名
           # F           L
           $ A C A A C A G    # (G)
(A1)       A A C A G $ A C    # (C1)
(A2)       A C A A C A G $   
(A3)       A C A G $ A C A    # (A1)
(A4)       A G $ A C A A C    # (C2)
(C1)       C A A C A G $ A    # (A2)
(C2)       C A G $ A C A A    # (A3)
(G)        G $ A C A A C A    # (A4)
```

4. 存储

* 存储时只需要存储**L列**和L列中**每个碱基的相对位置信息**（解决了内存占用率的问题）
* **L 列为 F 列的前一个**
* 对 **L 列排序**后可以得到 **F 列**
* 根据 L 列和 F 列可以**还原出整条序列**

### 二、 将 query 比对到ref上

```
CAA 
```

- 正向比对要从F列开始
- 反向比对要从L列开始
- 选择最优的方案作为比对结果

### 三、比对过程中的一些问题

1. Bowtie 不允许 gap-open， 这一问题在Bowtie2中的到了改进， Bowtie2 在比对情况较好的区域， 会利用NW & SW算法进行进一步的比对，从而将gap-open也考虑进来
2. 另外在选择最优比对时， 会考虑gap-open， gap-extension，reads quality等情况

### 四、总结
*	BWT算法解决了内存占用率过高的问题并且对运算速度做出了提升


